# LeetCode

1. twoSum: (1) Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.

2. recoverRotatedSortedArray: Given a rotated sorted array, recover it to sorted array in-place.（Ascending）

3. ReverseWordsInString: (151) Given an input string, reverse the string word by word.

4. rotateString: Given a string(Given in the way of char array) and an offset, rotate the string by offset in place. (rotate from left to right).

5. search2DMatrixII: (74) Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

        Integers in each row are sorted from left to right.
        The first integer of each row is greater than the last integer of the previous row.

6. firstBadVersion: (278) You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

7. findPeakElement: (162) A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞.

8. strStr: (28) Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

9. mergeSortedArray: (88) Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.

10. searchInsertPosition: (35) Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.

11. search2DMatrix: (74) Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
                Integers in each row are sorted from left to right.
                The first integer of each row is greater than the last integer of the previous row.

12. BinarySearch: The concepts of binary search.

13. medianOfTwoSortedArrays: (4) There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty.

14. searchInRotatedSortedArray: (33) Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n).

15. PartitionArray: (561) Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.

16. rotateString_LeetCodeVersion: (769) We are given two strings, A and B. A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. Return True if and only if A can become B after some number of shifts on A.

17. binaryTreeZigzagLevelTraversal: (103) Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

18. binaryTreeLevelOrderTraversal: (102) Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

19. searchRangeInBST: (700) Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL.

20. binaryTreePostorderTraversal: (145) Given a binary tree, return the postorder traversal of its nodes' values.

21. binaryTreePreorderTraversal: (144) Given a binary tree, return the preorder traversal of its nodes' values.

22. binaryTreeInorderTraversal: (94) Given a binary tree, return the inorder traversal of its nodes' values.

23. maximumDepthOfABinaryTree: (104) Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children..

24. mergeSort: The concepts of merge sort.
